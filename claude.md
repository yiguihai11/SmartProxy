# Claude 开发文档

## 项目概述

SmartProxy 是一个高性能的 SOCKS5 代理服务器，具有以下特点：
- 支持 TCP 和 UDP 代理
- 内置对象池优化内存使用
- 实时内存监控和 Web UI
- 支持多种缓冲区大小优化

## 项目结构

```
smartproxy/
├── socks5/           # 核心包
│   ├── socks5.go    # SOCKS5 协议实现
│   ├── pool.go      # 对象池实现
│   └── memory_monitor.go  # 内存监控
├── web/             # Web 服务
│   └── server.go    # HTTP API 服务器
├── web/static/      # 静态资源
│   ├── index.html   # 主页
│   ├── memory.html  # 内存监控页面
│   └── debug_memory.html  # 调试页面
├── cmd/             # 命令行工具
└── main.go          # 主入口
```

## 关键功能

### 1. 内存监控系统

- **实时统计**：监控内存分配、GC 次数、活跃连接等
- **对象池统计**：跟踪缓冲区池和连接池的使用情况
- **Web UI**：提供可视化监控界面

### 2. 对象池优化

- **多尺寸缓冲区池**：支持从 64B 到 128KB 的多种缓冲区大小
- **连接池**：复用 TCP 连接以提高性能
- **统计收集**：详细记录池的命中率和使用情况

### 3. API 端点

- `/api/memory/stats` - 基础内存统计
- `/api/memory/usage` - 内存使用详情
- `/api/memory/efficiency` - 内存效率分析
- `/api/memory/pools` - 对象池统计

## 开发工作流程规则

### 重要：每次代码修改后的必备步骤

1. **构建项目**：每次修改代码后，必须执行强制构建
   ```bash
   go build -o smartproxy
   ```

2. **Git 提交**：构建成功后，立即添加并提交到本地仓库
   ```bash
   git add .
   git commit -m "描述修改内容"
   ```

3. **严格遵守以下原则**：
   - **不修改无关代码**：只修改与当前任务直接相关的文件
   - **不自作聪明优化**：严格按照需求进行修改，不添加额外的"优化"
   - **最小化改动**：用最小的代码量实现需求
   - **及时提交**：每次完成一个功能或修复后立即提交

### 代码修改原则

1. **需求导向**：
   - 明确理解用户需求
   - 不随意添加功能
   - 不删除未要求删除的代码

2. **稳定性优先**：
   - 修改前先备份
   - 小步快跑，频繁提交
   - 确保每次修改不影响其他功能

3. **沟通确认**：
   - 不确定的需求主动询问
   - 复杂修改前先制定计划
   - 完成后汇报修改内容

## 开发指南

### 添加新的内存统计

1. 在 `MemoryStats` 结构体中添加新字段
2. 更新 `updateMemoryStats()` 函数
3. 在 Web 服务器中添加相应的 API 输出
4. 更新前端 HTML 显示新数据
5. **重要**：执行构建和 Git 提交

### 添加新的对象池

1. 实现 `PoolStats` 接口
2. 在创建池时注册到内存监控器
3. 更新 API 返回池统计数据
4. 在前端添加显示逻辑
5. **重要**：执行构建和 Git 提交

## 性能优化建议

1. **缓冲区使用**：
   - 根据数据量选择合适的缓冲区大小
   - 使用 `GetOptimized()` 方法获取优化的缓冲区
   - 及时归还缓冲区到池中

2. **连接管理**：
   - 使用连接池减少 TCP 握手开销
   - 设置合理的连接超时时间
   - 定期清理空闲连接

3. **内存管理**：
   - 监控 GC 频率和暂停时间
   - 避免频繁的大对象分配
   - 使用对象池复用对象

## 监控和调试

### 内存监控页面

访问 `/memory.html` 查看实时内存监控数据：
- 内存使用趋势图
- TCP/UDP/DNS 连接统计
- 对象池效率分析
- 详细的池统计数据

### 调试命令

```bash
# 运行代理服务器
go run *.go

# 查看内存统计
curl http://localhost:8080/api/memory/stats

# 查看对象池统计
curl http://localhost:8080/api/memory/pools
```

## 常见问题

### Q: 缓冲区分配图表不更新怎么办？
A: 检查 `updatePoolsData()` 函数是否正确更新数据，确保 `bufferAllocationChart` 在 `updateCharts()` 中被调用更新。

### Q: 如何添加新的监控指标？
A: 1. 在 Go 代码中添加统计收集逻辑
   2. 更新 API 返回数据
   3. 在前端添加显示元素和更新逻辑

### Q: 如何优化内存使用？
A: 1. 使用对象池复用对象
   2. 选择合适的缓冲区大小
   3. 及时释放不再使用的资源
   4. 监控 GC 性能

## 更新日志

- 2025-12-15: 修复了缓冲区分配图表不更新的问题
- 2025-12-15: 优化了连接池和 UDP 会话统计显示
- 2025-12-15: 修复了前端 JavaScript 错误导致的监控数据加载失败